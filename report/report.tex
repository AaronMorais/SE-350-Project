\documentclass[12pt]{report}

% Packages (keep sorted)
\usepackage{
    algorithm,      % For algorithm environment
    algpseudocode,  % For pseudocode
    hyperref,       % For PDF bookmarks
    tikz,           % For state diagrams
    color,
    listings
}

\definecolor{light-gray}{rgb}{0.9, 0.9, 0.9}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{
    backgroundcolor=\color{light-gray}, % Background color
    basicstyle=\footnotesize,        % the size of the fonts that are used for the code
    breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
    breaklines=true,                 % sets automatic line breaking
    captionpos=b,                    % sets the caption-position to bottom
    commentstyle=\color{mygreen},    % comment style
    deletekeywords={...},            % if you want to delete keywords from the given language
    escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
    extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
    keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
    keywordstyle=\color{blue},       % keyword style
    language=C,                      % the language of the code
    morekeywords={*,...},            % if you want to add more keywords to the set
    numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
    numbersep=5pt,                   % how far the line-numbers are from the code
    numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
    showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
    showstringspaces=false,          % underline spaces within strings only
    showtabs=false,                  % show tabs within strings adding particular underscores
    stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
    stringstyle=\color{mymauve},     % string literal style
    tabsize=2,                       % sets default tabsize to 2 spaces
    title=\lstname
}


% State diagrams (i.e. I/O)
\usetikzlibrary{
    shadows,
    positioning,
}
% TODO: move these to another file.
\tikzstyle{block} = [rectangle, draw,
    text width=5em, text centered, rounded corners, minimum height=4em]
\tikzstyle{line} = [draw]
\tikzstyle{cloud} = [draw, rectangle, node distance=3cm,
    minimum height=2em]

% PDF bookmarks setup (keep sorted)
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
}

\begin{document}

% Info section

% TODO come up with something more creative
\title{RTX Project Report}

% TODO check names %
\author{
    Xiang, Dian\\
    20431601\\
    \texttt{dxiang@uwaterloo.ca}
    \and
    Justin McGirr\\
    20413625\\
    \texttt{jmcgirr@uwaterloo.ca}
    \and
    Adrian Cheung\\
    20421743\\
    \texttt{a32cheun@uwaterloo.ca}
    \and
    Aaron Morais\\
    20413440\\
    \texttt{aemorais@uwaterloo.ca}
}

\maketitle

\begin{abstract}
    % Using the Keil Development Environment (Keil IDE) and LPC1768 boards using
    % the ARM instruction set, an operating system was implemented with basic
    % functionality throughout this project. The operating system offers a stable
    % and succinct API, and also tries to ensure high-performance.
    % It offers a message-passing interface between processes, and allows
    % processes to release the processor to share CPU time. Additionally, we
    % implemented memory management of the on-board memory, allowing processes to
    % dynamically acquire and release memory during our operating-system's
    % runtime.
    % I/O between keyboard input and display output on a UART connection was also
    % implemented, which allows users to interact with processes on the system in
    % near real-time. Overall, this operating system offers a minimal but fast
    % API, and is easily extendible with features necessary to implement a larger
    % and more feature-complete operating system with minimal overhead.
\end{abstract}

\tableofcontents
\listofalgorithms
\listoffigures

% NOTE(sanjay): uncomment these if we add any figures or tables
% \listoftables


\part{Introduction}
% TODO INTRODUCTION

\part{Kernel API}
% Make sure to include pseudocode and testing, if appropriate.

\chapter{RTX Primitives and Services}


\section{Memory Management}
\subsection{Description}
% TODO fill in figure blah
The RTX provides the utility of simple memory management of the heap. The main memory on the board (TODO: name the board) is divided into sections of the RTX Image, PCB data, the heap, and process stacks seen in figure blah.
*** TODO insert figure blah here ***

Board LPC17xx (TODO insert the real name) does not have the hardware to support virtual memory. Thus, a fixed memory management scheme is used with variable block sizes. The OS kernel is alway loaded into main memory. When the OS boots, a user stated number of PCBs and process stack are allocated. The OS also allocates memory for system processes such as the Keyboard Command Decoder Process (KCD) and the CRT Display Process. After allocation of PCBs and process stacks, the remaining memory is used for the heap, which is shared between all processes. This section will be focused on the memory management of the heap.

The heap is further divided into a variable number of blocks. Each block contains a header (HeapBlockHeader) and 128 bytes of data. Depending on the number of user and system processes, the number of available heap memory will vary. The size of the data can vary from 128 bytes but must be set at compile time. The OS supports two kernel calls that gives access to these memory blocks.

\subsection{Requesting Memory}
\begin{lstlisting}
void *request_memory_block();
\end{lstlisting}
\par The first functionality supported by the OS is the ability to request memory. This call gives back a pointer to a memory block in the heap. The size of the memory block is defined by the constant HEAP\_BLOCK\_SIZE, which defaults to 128 bytes. These blocks are used for storing local variables or as envelopes for interprocess communication (described in section TODO). The user must cast the memory block to the proper type for his or her own use. An example of the usage is provided below, which stores the numbers 0-31 in an array of size 32.
\begin{lstlisting}
void user_process() {
    int size = 32;

    int* array = (int*)request_memory_block();

    for( int i = 0; i < size; i++ ) {
        array[i] = i;
    }

    // ...

    release_memory_block( (void*)array );
}
\end{lstlisting}
% TODO maybe put a caption here CODE1

\par All processes will share the same heap memory pool. Thus, this primitive will block the process if the OS does not have anymore memory blocks to give out at the time, thus effecting the execution of the process. In that case, it will only be unblocked there is a new memory block available and if it has the highest priority on the list of processes waiting for a memory block. When using the memory block, the user must be aware of writing past the heap block size. The OS does not check for segmentation faulting. Thus, undefined behavior may occur. Also, the user must remember to release the memory block or memory leakage will occur.

\newpage
\subsection{Releasing Memory}
\begin{lstlisting}
int release_memory_block(void *memory_block);
\end{lstlisting}

\par The second functionality supported by the OS is the ability to release memory. This is a non-blocking call that returns the memory block back to the OS. This should be called when a message is received and not passed on or when the process is done using the memory block. If any process is blocked on memory, it will be unblocked and put to the ready queue. If the current process has lower priority than the unblocked process, then the current process will be preempted and the higher priority process will be executed instead. An example of this can be seen in figure CODE1 TODO on line 13.

\bigskip

\section{Processor Management}
\begin{lstlisting}
int release_processor();
\end{lstlisting}

\par The OS manages processes as though it is on a uniprocessor. A priority based scheme with context switching is used for scheduling processes. A process can voluntarily release the processor to the OS at any time during its execution. If there are errors in the call, it will return an error without releasing the processor to the OS. If there are no errors and the invoking process is ready to execute, it is put to the end of the ready queue of its priority. If there are no other processes of equal or higher priority, the process will be chosen to execute again. However, if there is, another process may be chosen for execution. Below is an example which prints an increasing number and releases the processor at every turn.

\begin{lstlisting}
void user_process() {
    static num = 0;
    while(1) {
        print(num++);
        release_processor();
    }
}
\end{lstlisting}

\section{Interprocess Communication}



\section{Description}

\section{Process Priority}

% TODO Sections are a bit fucked up after this point

\section{Interrupts and Their Han}
% Make sure to include pseudo-code and testing, if appropriate.

\section{Description}

\subsection{Block Layer}

\subsection{Metadata Layer}

\section{Theoretical Analysis}

\section{Measurements}

\chapter{Interrupts and Their Handlers / Processes}

\section{Description}

\chapter{System and User Processes}

\section{Description}

\subsection{`funProcess'}

\subsection{`schizophrenicProcess'}

\subsection{`fibProcess'}

\subsection{`memoryMuncherProcess'}

\subsection{`releaseProcess'}

\part{Initialization}

\part{Testing}

\part{Timing}

\chapter{Acquiring Timings}

\chapter{Timing Analysis}

\part{What We Learned}

\part{Major Design Changes}


\appendix
\chapter{Raw Measurement Data}
\label{appendix:raw_data}

\section{Trial Information}

\begin{tabular}{l | l | l}
    Trial&Total Runtime&Notes \\
    \hline
    1&4.219&Normal (no stress processes) \\
    2&7.754&Wall clock \\
    3&8.487&Normal (no stress processes)\\
    4&6.5&No Memory Muncher or Release Process \\
    5&30.988&Stress processes \\
\end{tabular}

\section{Function Runtime Profiling}
\begin{tabular}{l | l | l | l | l}
    Function & Trial & Time ($\mu s$) & \# of Calls & Average time / call ($\mu s$) \\
    \hline
    k\_sendMessage&1&601.58&552&1.090 \\
    k\_receiveMessage&1&408.22&565&0.723 \\
    k\_acquireMemoryBlock&1&244.12&294&0.830 \\
    k\_sendMessage&2&647.44&594&1.090 \\
    k\_receiveMessage&2&437.78&606&0.722 \\
    k\_acquireMemoryBlock&2&258.68&320&0.808 \\
    k\_sendMessage&3&630.99&579&1.090 \\
    k\_receiveMessage&3&426.83&591&0.722 \\
    k\_acquireMemoryBlock&3&259.24&321&0.808 \\
    k\_sendMessage&4&108.80&100&1.088 \\
    k\_receiveMessage&4&74.44&110&0.677 \\
    k\_acquireMemoryBlock&4&92.47&123&0.752 \\
    k\_sendMessage&5&750.63&687&1.093 \\
    k\_receiveMessage&5&497.09&693&0.717 \\
    k\_acquireMemoryBlock&5&329.90&447&0.738 \\
\end{tabular}

\end{document}